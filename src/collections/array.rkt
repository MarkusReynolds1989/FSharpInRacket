#lang racket/base

(require "../globals.rkt"
         (prefix-in Map. "map.rkt")
         racket/vector
         threading)

; Returns a new array that contains all pairings of elements from the first and second arrays.
(define (all-pairs array-one array-two)
  (define result (empty))
  (for ([index (in-range 0 (length array-one))])
    (set! result (append result (vector (list (get index array-one) (get index array-two))))))
  result)

; Builds a new array that contains the elements of the first
; array followed by the elements of the second.
(define (append array-one array-two)
  (vector-append array-one array-two))

; Returns the average of the elements of the array.
(define (average input)
  (/ (sum input) (length input)))

; Returns the average of the elements generated by applying the function
; to each element of the array.
(define (average-by projection input)
  (define mapped-values (map projection input))
  (average mapped-values))

; Reads a range of elements from the first array and write them into the second.
(define (array-blit dest dest-start src [src-start 0] [src-end (length src)])
  (vector-copy! dest dest-start src src-start src-end))

; TODO: choose - May only need to be used for typed racket where we have an option type.
; Applies the given function to each element of the array. Returns the new array
; comprised of the results x for each element where the function returns Some(x).

; Divides the input array into chunks of size at most chunk-size.
(define (chunk-by-size chunk-size input)
  (define result (empty))
  (for ([index (in-range 0 (- (+ (length input) 1) chunk-size))])
    (set! result (append result (vector (~>> (skip index input) (take chunk-size))))))
  result)

; TODO: collect - implement map and concat
; For each element of the array, applies the given function. Concatenates all the results and
; return the combined array.

; TODO: Finish compare-with.
; Compares two arrays using the givern comparison function, element by element.
(define (compare-with comparer array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    #:break (not (= (comparer (get index array-one) (get index array-two))))
    1))

; TODO: concat - may not need this, this is to take Seqs of arrays and concat them into one.

(define (contains value array)
  (define result #f)
  (for ([index (in-range 0 (length array))])
    (when (equal? value (get index array))
      (set! result #t)))
  result)

(define (copy array)
  (define new-array (create (length array) (get 0 array)))
  (array-blit new-array 0 array)
  new-array)

(define (copy-to in-array out-array)
  (array-blit out-array 0 in-array 0 (length out-array)))

(define (create count init-value)
  (make-vector count init-value))

; Applies a key-generating function to each element of an array and returns an array
; yielding unique keys and their number of occurrences in the original array.
; Fold over a map, increment the value everytime the key is found again. Then return the map
; as an array.
(define (count-by projection input)
  (~>> (fold (fn (state x)
                 (define key (projection x))
                 (if (Map.contains-key key state)
                     (Map.change key (+ (Map.get key state) 1) state)
                     (Map.add key 1 state)))
             (Map.empty)
             input)
       (Map.to-array)))

; TODO: array-distinct - just a hashmap or set if they have it.

; TODO: array-distinct-by

(define (empty)
  (vector))

(define (exactly-one array)
  (and (= (length array) 1) (get 0 array)))

; TODO: array-except

(define (exists predicate array)
  (define result #f)
  (for ([i (in-range 0 (length array))])
    (when (predicate (get i array))
      (set! result #t)))

  result)

; TODO: array-exists-two

; TODO: array-fill target target-index count value

(define (filter predicate array)
  (fold (fn (acc item) (if (predicate item) (append (vector item) acc) acc))
        (create 0 (get 0 array))
        array))

(define (fold folder state array)
  (let loop ([index 0] [folder folder] [state state] [array array])
    (cond
      [(= index (length array)) state]
      [else (loop (+ 1 index) folder (folder state (get index array)) array)])))

; TODO: array-fold-two

; TODO: array-fold-back

; TODO: array-fold-back-two

(define (for-all predicate array)
  (let loop ([index 0] [predicate predicate] [array array])
    (cond
      [(= index (length array)) #t]
      [(not (predicate (get index array))) #f]
      [else (loop (+ index 1) predicate array)])))

; TODO: array-for-all-two

(define (get index array)
  (vector-ref array index))

; TODO: array-group-by

(define (head array)
  (get 0 array))

(define (init count
              initializer)
  (for/vector ([index (in-range 0 count)])
    (initializer index)))

; TODO: array-insert-at

; TODO: array-insert-many-at

; TODO: array-is-empty?
(define (is-empty array)
  (= (length array) 0))

(define (iter action array)
  (for ([index (in-range 0 (length array))])
    (action (get index array))))

(define (iter-two action array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    (action (get index array-one) (get index array-two))))

(define (iter-index action array)
  (for ([index (in-range 0 (length array))])
    (action index (get index array))))

(define (iter-index-two action array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    (action index (get index array-one) (get index array-two))))

(define (last array)
  (get (- (length array) 1) array))

(define (length array)
  (vector-length array))

;Builds a new array whose elements are the results of applying the given function to each of the elements to the array.
(define (map mapper array)
  (for/vector ([item array])
    (mapper item)))

(define (skip size array)
  (vector-drop array size))

(define (sum array)
  (fold (fn (acc item) (+ acc item)) 0 array))

;(define (sort array)
;  (vector-sort array))

(define (take size input)
  (vector-take input size))

(provide (all-defined-out))

(module+ test
  (require rackunit)
  (define old-array (vector 1 2 3 4))
  (define new-array (vector 0 0 0 0))

  (test-equal? "All-pairs works correctly."
               (all-pairs (vector 1 2 3 4) (vector 1 2 3 4))
               (vector '(1 1) '(2 2) '(3 3) '(4 4)))

  (test-equal? "Append test." (append (vector 1 2 3) (vector 4 5 6)) (vector 1 2 3 4 5 6))

  (test-equal? "Average works correctly." (average (vector 2 2 4 4)) 3)

  (test-equal? "Average-by works correctly."
               (average-by (fn (x) (head x)) (vector #(2 1) #(2 1) #(4 1) #(4 1)))
               3)

  (test-equal? "Chunk-by-size works correctly."
               (chunk-by-size 2 (vector 1 2 3 4))
               (vector (vector 1 2) (vector 2 3) (vector 3 4)))

  (test-true "Contains test should resolve to true." (contains -100 (vector 1 2 3 4 100 23 -100)))

  (test-false "Contains test should resolve to false."
              (contains "blue" (vector "red" "yellow" "green")))

  ;(test-eq? "Compare-with all are equal."
  ;          (compare-with (fn (x y) (if (= x y) 0 1)) ((vector 1 2 3 4) (vector 1 2 3 4)))
  ;          0)

  (define count-by-results (count-by (fn (x) x) #(1 1 1)))

  (test-equal? "Count-by works" (count-by (fn (x) x) #(1 1 1)) #((1 3)))

  (test-equal? "Count-by more complicated."
               (count-by (fn (x) x) #(1 1 1 1 3 3 3 3 2 2 2 0))
               #((0 1) (1 4) (2 3) (3 4)))

  (test-equal? "Copy-to works correctly"
               old-array
               (begin
                 (copy-to new-array old-array)
                 new-array))

  (test-case "Old array isn't copying, new pointer."
    (check-not-eq? old-array (copy old-array)))

  (test-equal? "Old array matches new pointers." (copy old-array) old-array)

  (test-equal? "Creating an array works correctly." (create 3 0) (vector 0 0 0))

  (test-false "Exactly-one test, array has more than one." (exactly-one (vector 1 2)))

  (test-eq? "Exactly-one test, array has exactly one." (exactly-one (vector 1)) 1)

  (test-true "Exists test, 1 is in the array." (exists (fn (item) (= item 1)) (vector 1 2 3 4)))

  (test-false "Exists test, blue is not in the array."
              (exists (fn (item) (equal? item "blue")) (vector "red" "yellow" "green")))

  (test-eq? "Fold test, array should add up to 10."
            (fold (fn (acc item) (+ acc item)) 0 (vector 1 2 3 4))
            10)

  (test-equal? "Filter takes any item equal to one."
               (filter (fn (item) (= item 1)) (vector 1 1 1 2 2 2))
               (vector 1 1 1))

  (test-equal? "Filter takes any string length that is greater than 3"
               (filter (fn (item) (> (string-length item) 3)) (vector "one" "two" "three"))
               (vector "three"))

  (test-true "For-all returns true, the item in the vector is greater than 2."
             (for-all (fn (item) (> item 2)) (vector 3 4 5 6 7)))

  (test-false "For-all returns false because no items match."
              (for-all (fn (item) (> item 2)) (vector 1 2 3 4 5)))

  (test-eq? "Getting the first element returns 1." (get 0 (vector 1 2 3 4)) 1)

  (test-equal? "Mapping over an array works correctly, simple addition."
               (map (fn (item) (add1 item)) (vector 1 2 3 4))
               (vector 2 3 4 5))

  (test-equal? "Mapping over an array works correctly, length of strings."
               (map (fn (item) (string-length item)) (vector "one" "two" "three"))
               (vector 3 3 5))

  (test-equal? "Initializing an array works correctly."
               (init 3
                     (fn (item) (add1 item)))
               (vector 1 2 3))

  (test-true "The array is empty." (is-empty (vector)))

  (test-false "The array is not empty." (is-empty (vector 1)))

  (test-eq? "The last item in the array is 4." (last (vector 1 2 3 4)) 4))
