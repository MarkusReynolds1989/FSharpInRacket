#lang racket/base

(require "../globals.rkt"
         (prefix-in Map. "map.rkt")
         (prefix-in List. "list.rkt")
         racket/vector
         threading)

; Returns a new array that contains all pairings of elements from the first and second arrays.
(define (all-pairs array-one array-two)

  (define result (empty))

  (for ([index (in-range 0 (length array-one))])
    (set! result (append result (vector (list (get index array-one) (get index array-two))))))
  result)

; Builds a new array that contains the elements of the first
; array followed by the elements of the second.
(define (append array-one array-two)

  (vector-append array-one array-two))

; Returns the average of the elements of the array.
(define (average input)

  (/ (sum input) (length input)))

; Returns the average of the elements generated by applying the function
; to each element of the array.
(define (average-by projection input)
  (define mapped-values (map projection input))
  (average mapped-values))

; Reads a range of elements from the first array and write them into the second.
(define (array-blit dest dest-start src [src-start 0] [src-end (length src)])
  (vector-copy! dest dest-start src src-start src-end))

; TODO: choose - May only need to be used for typed racket where we have an option type.
; Applies the given function to each element of the array. Returns the new array
; comprised of the results x for each element where the function returns Some(x).

; Divides the input array into chunks of size at most chunk-size.
(define (chunk-by-size chunk-size input)
  (define result (empty))
  (for ([index (in-range 0 (- (+ (length input) 1) chunk-size))])
    (set! result (append result (vector (~>> (skip index input) (take chunk-size))))))
  result)

; TODO: collect - implement map and concat
; For each element of the array, applies the given function. Concatenates all the results and
; return the combined array.

; TODO: Finish compare-with.
; Compares two arrays using the givern comparison function, element by element.
(define (compare-with comparer array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    #:break (not (= (comparer (get index array-one) (get index array-two))))
    1))

; TODO: concat - may not need this, this is to take Seqs of arrays and concat them into one.

; Tests if the array contains the specified element.
(define (contains value array)
  (define result #f)
  (for ([index (in-range 0 (length array))])
    (when (equal? value (get index array))
      (set! result #t)))
  result)

; Builds a new array that contains the elements of the array given.
(define (copy array)
  (define new-array (create (length array) (get 0 array)))
  (array-blit new-array 0 array)
  new-array)

; Applies a key-generating function to each element of an array and returns an array
; yielding unique keys and their number of occurrences in the original array.
; Fold over a map, increment the value everytime the key is found again. Then return the map
; as an array.
(define (count-by projection input)
  (~>> (fold (fn (state x)
                 (define key (projection x))
                 (if (Map.contains-key key state)
                     (Map.change key (+ (Map.get key state) 1) state)
                     (Map.add key 1 state)))
             (Map.empty)
             input)
       (Map.to-array)))

; Creates an array whose elements are all initially the given value.
(define (create count init-value)
  (make-vector count init-value))

; Returns an array that contains no duplicate entries according to generic hash and
; equality compairsons on the entries. If an element occurs multiple times in the
; array then the later occurences are discarded.
(define (distinct input)
  (~>>
   (fold (fn (state x) (if (Map.contains-key x state) state (Map.add x 1 state))) (Map.empty) input)
   (Map.keys)
   (List.to-array)))

; Returns an array that contains no duplicate entries according to the
; generic hash and comparisons on keys returned by the give key-generating function.
; If an element occurs multiple times in teh array then the later
; occurences are discarded.
(define (distinct-by projection input)
  (~>> input (map (fn (x) (projection x))) (distinct)))

; Returns an empty array.
(define (empty)
  (vector))

; Returns the only element of an array.
(define (exactly-one array)
  (and (= (length array) 1) (get 0 array)))

; TODO: except - Come back to this after sequence is ready.
; Returns a new list with the distinct elements of the input array with do not appear
; in the items-to-exclude sequence, using generic hash and equality comparison to compare values.

; Tests if any element of the array satisfies the given predicate.
(define (exists predicate array)
  (define result #f)
  (for ([i (in-range 0 (length array))])
    (when (predicate (get i array))
      (set! result #t)))
  result)

; Tests if any pair of corresponding elements of the arrays satisifes the given predicate.
(define (exists-two predicate array-one array-two)
  (define result #f)
  (for ([index (in-range 0 (length array-one))])
    (when (predicate (get index array-one) (get index array-two))
      (set! result #t)))
  result)

; Fills a range of elements of the array with the given value.
(define (fill target target-index count value)
  (for ([index (in-range target-index count)])
    (set target index value)))

; Returns a new collection containing only the elements of the collection for which the given
; predicate returns "true".
(define (filter predicate input)
  (fold (fn (acc item) (if (predicate item) (append (vector item) acc) acc))
        (create 0 (get 0 input))
        input))

; Applies a function to each element of the collection, threading an accumulator
; argument through the computation. If the input function is f and the elements are
; i0..iN then computes f(...(f s i0)...) iN.
(define (fold folder state input)
  (let loop ([index 0] [folder folder] [state state] [array input])
    (cond
      [(= index (length array)) state]
      [else (loop (+ 1 index) folder (folder state (get index array)) array)])))

; TODO: fold-two

; TODO: fold-back

; TODO: fold-back-two

(define (for-all predicate array)
  (let loop ([index 0] [predicate predicate] [array array])
    (cond
      [(= index (length array)) #t]
      [(not (predicate (get index array))) #f]
      [else (loop (+ index 1) predicate array)])))

; TODO: array-for-all-two

; Gets an element of an array.
(define (get index array)
  (vector-ref array index))

; Applies a key-generating function to each element of an array and yields an array
; of unique keys. Each unique key contains an array of all elements that match that key.
(define (group-by projection array)
  0)

(define (head array)
  (get 0 array))

(define (init count
              initializer)
  (for/vector ([index (in-range 0 count)])
    (initializer index)))

; TODO: insert-at

; TODO: insert-many-at

; Returns true if the given array is empty, otherwise false.
(define (is-empty array)
  (= (length array) 0))

(define (iter action array)
  (for ([index (in-range 0 (length array))])
    (action (get index array))))

(define (iter-two action array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    (action (get index array-one) (get index array-two))))

(define (iter-index action array)
  (for ([index (in-range 0 (length array))])
    (action index (get index array))))

(define (iter-index-two action array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    (action index (get index array-one) (get index array-two))))

(define (last array)
  (get (- (length array) 1) array))

(define (length array)
  (vector-length array))

;Builds a new array whose elements are the results of applying the given function to each of the elements to the array.
(define (map mapper array)
  (for/vector ([item array])
    (mapper item)))

; Sets an element of an array.
(define (set array index value)
  (vector-set! array index value))

(define (skip size array)
  (vector-drop array size))

(define (sum array)
  (fold (fn (acc item) (+ acc item)) 0 array))

;(define (sort array)
;  (vector-sort array))

(define (take size input)
  (vector-take input size))

(provide (all-defined-out))

(module+ test
  (require rackunit)

  (test-equal? "All-pairs works correctly."
               (all-pairs (vector 1 2 3 4) (vector 1 2 3 4))
               (vector '(1 1) '(2 2) '(3 3) '(4 4)))

  (test-equal? "Append test." (append (vector 1 2 3) (vector 4 5 6)) (vector 1 2 3 4 5 6))

  (test-equal? "Average works correctly." (average (vector 2 2 4 4)) 3)

  (test-equal? "Average-by works correctly."
               (average-by (fn (x) (head x)) (vector #(2 1) #(2 1) #(4 1) #(4 1)))
               3)

  (test-equal? "Chunk-by-size works correctly."
               (chunk-by-size 2 (vector 1 2 3 4))
               (vector (vector 1 2) (vector 2 3) (vector 3 4)))

  (test-true "Contains test should resolve to true." (contains -100 (vector 1 2 3 4 100 23 -100)))

  (test-false "Contains test should resolve to false."
              (contains "blue" (vector "red" "yellow" "green")))

  (test-equal? "Copy works correctly." (copy #(1 2 3)) #(1 2 3))

  (test-equal? "Count-by works" (count-by (fn (x) x) #(1 1 1)) #((1 3)))

  (test-equal? "Count-by more complicated."
               (count-by (fn (x) x) #(1 1 1 1 3 3 3 3 2 2 2 0))
               #((0 1) (1 4) (2 3) (3 4)))

  (test-equal? "Creating an array works correctly." (create 3 0) (vector 0 0 0))

  (test-equal? "Distinct works." (distinct #(1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4)) #(1 2 3 4))

  (test-equal? "Distinct-by works."
               (distinct-by (fn (x) (string-length x)) #("one" "one" "three" "three"))
               #(3 5))

  (test-false "Exactly-one test, array has more than one." (exactly-one (vector 1 2)))

  (test-eq? "Exactly-one test, array has exactly one." (exactly-one (vector 1)) 1)

  (test-true "Exists test, 1 is in the array." (exists (fn (item) (= item 1)) (vector 1 2 3 4)))

  (test-false "Exists test, blue is not in the array."
              (exists (fn (item) (equal? item "blue")) (vector "red" "yellow" "green")))

  (test-true "Exists-two works correctly." (exists-two (fn (x y) (= x y)) #(1 2 3 4) #(2 3 6 4)))

  (test-case "Fill works correctly."
    (define filled (vector 1 2 3 4))
    (fill filled 1 2 3)
    (check-equal? filled #(1 3 3 4)))

  (test-eq? "Fold test, array should add up to 10."
            (fold (fn (acc item) (+ acc item)) 0 (vector 1 2 3 4))
            10)

  (test-equal? "Filter takes any item equal to one."
               (filter (fn (item) (= item 1)) (vector 1 1 1 2 2 2))
               (vector 1 1 1))

  (test-equal? "Filter takes any string length that is greater than 3"
               (filter (fn (item) (> (string-length item) 3)) (vector "one" "two" "three"))
               (vector "three"))

  (test-true "For-all returns true, the item in the vector is greater than 2."
             (for-all (fn (item) (> item 2)) (vector 3 4 5 6 7)))

  (test-false "For-all returns false because no items match."
              (for-all (fn (item) (> item 2)) (vector 1 2 3 4 5)))

  (test-eq? "Getting the first element returns 1." (get 0 (vector 1 2 3 4)) 1)

  (test-equal? "Mapping over an array works correctly, simple addition."
               (map (fn (item) (add1 item)) (vector 1 2 3 4))
               (vector 2 3 4 5))

  (test-equal? "Mapping over an array works correctly, length of strings."
               (map (fn (item) (string-length item)) (vector "one" "two" "three"))
               (vector 3 3 5))

  (test-equal? "Initializing an array works correctly."
               (init 3
                     (fn (item) (add1 item)))
               (vector 1 2 3))

  (test-true "The array is empty." (is-empty (vector)))

  (test-false "The array is not empty." (is-empty (vector 1)))

  (test-eq? "The last item in the array is 4." (last (vector 1 2 3 4)) 4))
